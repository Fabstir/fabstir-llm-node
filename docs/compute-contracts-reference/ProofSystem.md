# ProofSystem Contract Documentation

## Current Implementation

**Contract Address**: `0x2ACcc60893872A499700908889B38C5420CBcFD1`
**Network**: Base Sepolia
**Status**: ‚úÖ ACTIVE - Configured for S5 Off-Chain Proof Storage
**Last Updated**: October 14, 2025

> **üö® CRITICAL UPDATE**: S5 Off-Chain Proof Storage (Oct 14, 2025)
>
> **Proof verification model has fundamentally changed**:
> - **Before**: Full 221KB proofs submitted on-chain, verified immediately
> - **After**: Only hash (32 bytes) + CID (string) submitted on-chain
> - **Why**: STARK proofs exceeded RPC transaction limit (128KB), causing all submissions to fail
> - **Impact**: ProofSystem configured but NOT actively verifying on-chain
> - **Trust Model**: Contract trusts host's hash; disputes fetch full proof from S5

### Overview

The ProofSystem contract was originally designed for EZKL-based on-chain proof verification. **As of October 14, 2025**, the system has migrated to S5 off-chain proof storage to solve RPC transaction size limits.

**Current Role**:
- Configured in JobMarketplaceWithModels for future dispute resolution
- Not actively called during proof submission
- Full proofs stored in S5 decentralized storage
- Only cryptographic hashes stored on-chain

### Key Features (Pre-S5 Design)
- **EZKL Proof Verification**: Originally validated zero-knowledge proofs on-chain (now off-chain)
- **Replay Prevention**: Originally tracked verified proofs (now hash-based)
- **Batch Verification**: Process multiple proofs efficiently (deprecated)
- **Circuit Registry**: Maps models to verification circuits (preserved)
- **Stateless Design**: No dependency on JobMarketplace state (preserved)

### New Features (S5 Storage - Oct 14, 2025)
- **Hash-Based Integrity**: SHA256 hash verification prevents proof tampering
- **S5 Decentralized Storage**: Full proofs stored off-chain in S5 network
- **On-Demand Verification**: Proofs retrieved and verified only during disputes
- **Transaction Size Reduction**: 221KB ‚Üí 300 bytes (737x smaller)
- **Cost Efficiency**: ~$50 ‚Üí ~$0.001 per proof submission (5000x cheaper)

### Recent Fixes (January 4, 2025)
- **Internal Function Call**: Fixed `this.verifyEKZL` to `_verifyEKZL` internal call
- **USDC Compatibility**: Now works correctly with token-based sessions
- **Gas Optimization**: Reduced verification costs

### Architecture

```solidity
contract ProofSystem is IProofSystem {
    // Replay prevention
    mapping(bytes32 => bool) public verifiedProofs;
    
    // Circuit management
    mapping(bytes32 => bool) public registeredCircuits;
    mapping(address => bytes32) public modelCircuits;
    
    // Verification functions
    function verifyEKZL(bytes calldata proof, address prover, uint256 tokens) external view returns (bool)
    function verifyAndMarkComplete(bytes calldata proof, address prover, uint256 tokens) external returns (bool)
}
```

### Integration with JobMarketplace (Updated for S5)

**Current Contract**: JobMarketplaceWithModels (`0xc6D44D7f2DfA8fdbb1614a8b6675c78D3cfA376E`)

**OLD FLOW** (Pre-October 14, 2025 - ‚ùå DEPRECATED):
1. Host calls `submitProofOfWork(jobId, proofBytes, tokens)` with 221KB proof
2. Marketplace calls `verifyAndMarkComplete()` on ProofSystem
3. ProofSystem verifies proof on-chain
4. If valid, proof hash is marked as used
5. Marketplace credits proven tokens to session
**Problem**: Step 1 failed because 221KB exceeds 128KB RPC limit

**NEW FLOW** (S5 Off-Chain Storage - ‚úÖ ACTIVE):
1. Host generates STARK proof (221KB) off-chain
2. Host uploads proof to S5 ‚Üí receives CID
3. Host calculates SHA256 hash of proof
4. Host calls `submitProofOfWork(jobId, tokensClaimed, hash, cid)` (~300 bytes)
5. Marketplace stores hash + CID on-chain (NO ProofSystem call)
6. Marketplace credits proven tokens immediately (trusts hash)
7. **On Dispute**: Retrieve proof from S5, verify against hash, then verify validity

**Configuration**: ProofSystem is configured via `setProofSystem()` on JobMarketplaceWithModels but is NOT actively called during normal operation.

## S5 Off-Chain Proof Storage Architecture

### The Problem That Forced This Change

STARK proofs generated by RISC0 are approximately **221KB in size**, which exceeds:
- Base Sepolia RPC transaction limit: **128KB**
- Ethereum max calldata: **~1.5MB** (theoretical, but RPC limits are lower)

**Result**: **100% of proof submissions were failing** with "oversized data" errors, making the entire proof-of-work system non-functional.

### The Solution: Hash + CID Pattern

Instead of submitting full proofs on-chain, hosts now:

1. **Generate** proof off-chain (221KB STARK proof)
2. **Upload** proof to S5 decentralized storage ‚Üí receive CID
3. **Hash** proof using SHA256 ‚Üí 32-byte hash
4. **Submit** only hash + CID to blockchain (~300 bytes)

**Storage Comparison**:
```
On-Chain (Old):    221,000 bytes per proof
On-Chain (New):         ~300 bytes per proof (hash + CID)
Off-Chain (S5):     221,000 bytes (decentralized)
```

**Transaction Size**: 737x reduction (221KB ‚Üí 300 bytes)
**Storage Cost**: 5000x reduction (~$50 ‚Üí ~$0.001)

### Trust and Security Model

#### Old Model (On-Chain Verification)
```
Submit Proof ‚Üí ProofSystem.verify() ‚Üí Payment Released
             (cryptographic verification)
```
**Security**: Cryptographically guaranteed correctness
**Problem**: Proofs too large to submit

#### New Model (Hash Commitment)
```
Submit Hash+CID ‚Üí Payment Released (immediate)
                   ‚Üì
              Store hash on-chain
                   ‚Üì
         Dispute ‚Üí Retrieve from S5 ‚Üí Verify
```
**Security**: Hash commitment + dispute resolution
**Trade-off**: Trust during happy path, verify on dispute

#### Security Properties

**Integrity Protection**:
- SHA256 hash cryptographically binds to specific proof
- Host cannot change proof after submission (hash mismatch)
- Proof tampering detectable during retrieval

**Availability Guarantees**:
- S5 decentralized storage network (multiple nodes)
- Content-addressable (CID based on content hash)
- Redundant storage across network

**Dispute Resolution**:
1. Challenger retrieves proof from S5 using CID
2. Verify SHA256(retrieved_proof) == on_chain_hash
3. If hash matches, verify proof validity using ProofSystem
4. If proof invalid, slash host's stake

### SessionJob Struct Changes

**Added 2 new fields** to SessionJob struct:

```solidity
struct SessionJob {
    // ... existing 16 fields ...
    bytes32 lastProofHash;  // NEW: SHA256 hash of most recent proof
    string lastProofCID;    // NEW: S5 CID for proof retrieval
}
```

Now **18 fields total** (was 16 fields).

### Breaking Changes

#### Function Signature Changed

**OLD** (`0xe169A4B57700080725f9553E3Cc69885fea13629`):
```solidity
function submitProofOfWork(
    uint256 jobId,
    bytes calldata ekzlProof,  // 221KB proof bytes
    uint256 tokensInBatch
) external returns (bool verified)
```

**NEW** (`0xc6D44D7f2DfA8fdbb1614a8b6675c78D3cfA376E`):
```solidity
function submitProofOfWork(
    uint256 jobId,
    uint256 tokensClaimed,
    bytes32 proofHash,         // SHA256 hash (32 bytes)
    string calldata proofCID   // S5 CID for retrieval
) external
```

#### Event Changed

**OLD**:
```solidity
event ProofSubmitted(
    uint256 indexed jobId,
    address indexed host,
    uint256 tokensClaimed,
    bytes32 proofHash,
    bool verified
)
```

**NEW**:
```solidity
event ProofSubmitted(
    uint256 indexed jobId,
    address indexed host,
    uint256 tokensClaimed,
    bytes32 proofHash,
    string proofCID  // NEW: For off-chain indexing
)
```

### Migration Guide

**For Node Operators**:
```javascript
// OLD (‚ùå No longer works)
const proof = await generateProof(jobData);
await marketplace.submitProofOfWork(jobId, proof, 1000);

// NEW (‚úÖ Required)
const proof = await generateProof(jobData);
const proofCID = await s5.uploadBlob(proof);
const proofHash = '0x' + crypto.createHash('sha256').update(proof).digest('hex');
await marketplace.submitProofOfWork(jobId, 1000, proofHash, proofCID);
```

**For Verifiers/Auditors**:
```javascript
// Retrieve and verify proof from S5
const storedProof = await s5.downloadBlob(session.lastProofCID);

// Verify hash matches on-chain commitment
const calculatedHash = '0x' + crypto.createHash('sha256').update(storedProof).digest('hex');
if (calculatedHash !== session.lastProofHash) {
  throw new Error('Proof integrity check failed!');
}

// Verify proof validity (can be done off-chain)
const isValid = await proofSystem.verifyEKZL(storedProof, host, tokens);
if (!isValid) {
  // Initiate dispute, slash host stake
}
```

### Key Functions

#### Verification Functions

```solidity
// Basic verification (view only, no state change)
function verifyEKZL(
    bytes calldata proof,
    address prover,
    uint256 claimedTokens
) external view returns (bool)

// Verify and mark as used (prevents replay)
function verifyAndMarkComplete(
    bytes calldata proof,
    address prover,
    uint256 claimedTokens
) external returns (bool)

// Batch verification
function verifyBatch(
    bytes[] calldata proofs,
    address prover,
    uint256[] calldata tokenCounts
) external returns (bool)
```

#### Circuit Management

```solidity
// Register a model's verification circuit
function registerModelCircuit(
    address model,
    bytes32 circuitHash
) external onlyOwner

// Check if circuit is registered
function isCircuitRegistered(bytes32 circuitHash) external view returns (bool)

// Get model's circuit
function getModelCircuit(address model) external view returns (bytes32)
```

### Proof Validation Logic

The current implementation performs basic validation:

```solidity
function _verifyEKZL(
    bytes calldata proof,
    address prover,
    uint256 claimedTokens
) internal view returns (bool) {
    // Basic validation
    if (proof.length < 64) return false;  // Minimum proof size
    if (claimedTokens == 0) return false; // Must claim tokens
    if (prover == address(0)) return false; // Valid prover
    
    // Extract proof hash (first 32 bytes)
    bytes32 proofHash;
    assembly {
        proofHash := calldataload(proof.offset)
    }
    
    // Check not already verified (replay prevention)
    if (verifiedProofs[proofHash]) return false;
    
    // TODO: In production, call actual EZKL verifier
    return true;
}
```

### Proof Requirements

For a proof to be valid:

1. **Size**: Minimum 64 bytes
2. **Tokens**: Must claim at least 1 token (MIN_PROVEN_TOKENS enforced by marketplace)
3. **Prover**: Must be valid address
4. **Uniqueness**: Proof hash must not be previously used
5. **Future**: Will verify against EZKL circuit

### Events

```solidity
event ProofVerified(bytes32 indexed proofHash, address indexed prover, uint256 tokens)
event CircuitRegistered(bytes32 indexed circuitHash, address indexed model)
event BatchProofVerified(bytes32[] proofHashes, address indexed prover, uint256 totalTokens)
```

### Security Considerations

1. **Replay Prevention**: Each proof can only be used once
2. **Access Control**: Only owner can register circuits
3. **Validation**: Multiple checks before accepting proof
4. **Stateless Verification**: No dependencies on external state
5. **Future EZKL Integration**: Designed for drop-in EZKL verifier

### Gas Optimization

| Operation | Gas Cost | Notes |
|-----------|----------|-------|
| verifyEKZL (view) | ~5,000 | Read-only check |
| verifyAndMarkComplete | ~25,000 | State update included |
| verifyBatch (10 proofs) | ~180,000 | ~18k per proof |

### Batch Verification

For efficiency with multiple proofs:

```solidity
// Submit multiple proofs at once
function verifyBatch(
    bytes[] calldata proofs,
    address prover,
    uint256[] calldata tokenCounts
) external returns (bool) {
    require(proofs.length == tokenCounts.length, "Length mismatch");
    require(proofs.length <= 10, "Batch too large");
    
    for (uint256 i = 0; i < proofs.length; i++) {
        require(_verifyEKZL(proofs[i], prover, tokenCounts[i]), "Invalid proof");
        // Mark each proof as used
    }
    
    emit BatchProofVerified(proofHashes, prover, totalTokens);
    return true;
}
```

### Future EZKL Integration

The contract is designed for future EZKL verifier integration:

1. **Circuit Registry**: Already supports model‚Üícircuit mapping
2. **Verification Hook**: `_verifyEKZL` can call external verifier
3. **Proof Format**: Expects EZKL-compatible proof structure
4. **Public Inputs**: Token count and prover address as public inputs

### Testing Proofs

For testing, proofs must be at least 64 bytes:

```javascript
// JavaScript test example
const proof = ethers.utils.concat([
    ethers.utils.keccak256("0x1234"), // 32 bytes
    ethers.utils.keccak256("0x5678")  // 32 bytes
]);

await marketplace.submitProofOfWork(jobId, proof, 100);
```

### Deployment History

| Date | Address | Changes |
|------|---------|---------|
| Jan 4, 2025 | `0x2ACcc60893872A499700908889B38C5420CBcFD1` | Fixed internal call |
| Jan 3, 2025 | `0x48f94914979eD6B0e16c6E4E04Bfa8a8041DcF1D` | Had external call bug |
| Dec 2024 | Various | Earlier versions |

### Best Practices

1. **For Hosts**:
   - Generate unique proofs for each submission
   - Include sufficient entropy in proofs
   - Submit proofs promptly at checkpoints

2. **For Marketplace Integration**:
   - Always use `verifyAndMarkComplete()` for state changes
   - Check return value before crediting tokens
   - Handle verification failures gracefully

3. **For Circuit Deployment**:
   - Register circuits before model usage
   - Use standardized circuit formats
   - Version circuits for upgrades

### Migration Notes

When integrating real EZKL verifier:

1. Deploy EZKL verifier contract
2. Update `_verifyEKZL` to call verifier
3. Register model circuits
4. Test with real proofs
5. No changes needed in JobMarketplace

### References

- [S5_PROOF_STORAGE_DEPLOYMENT.md](../../S5_PROOF_STORAGE_DEPLOYMENT.md) - **NEW** S5 proof storage deployment guide
- [JobMarketplace.md](./JobMarketplace.md) - Integration details with S5 storage
- [ARCHITECTURE.md](../../ARCHITECTURE.md) - S5 architecture overview
- [SESSION_JOBS.md](../../SESSION_JOBS.md) - Proof checkpoint system
- [EZKL Documentation](https://docs.ezkl.xyz/) - External EZKL docs
- [S5 Documentation](https://docs.sfive.net/) - S5 decentralized storage
- [Source Code](../../../src/ProofSystem.sol) - Contract implementation
- [Tests](../../../test/ProofSystem/) - Test coverage