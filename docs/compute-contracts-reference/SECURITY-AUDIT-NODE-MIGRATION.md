# Node Software Migration Guide: Security Audit Remediation

**Branch:** `fix/security-audit-remediation`
**Date:** January 6, 2026
**Network:** Base Sepolia (Chain ID: 84532)

---

## Executive Summary

This document covers all changes required for host node software from the security audit remediation. **The host node is the critical component** because hosts must now **sign their proofs** before submission.

### Critical Change

**The host wallet must now cryptographically sign every proof submission.** Without this signature, proof submissions will be rejected by the contract.

---

## 1. BREAKING CHANGE: Proof Signing Required

### What Changed

The `submitProofOfWork` function now requires the host to sign a commitment to the proof data. This prevents:
- Unauthorized proof submissions
- Token count manipulation
- Replay attacks

### Old Flow (NO LONGER WORKS)

```
1. Generate proof data
2. Upload to S5, get CID
3. Calculate proofHash = keccak256(proofData)
4. Submit: submitProofOfWork(sessionId, tokens, proofHash, proofCID)
```

### New Flow (REQUIRED)

```
1. Generate proof data
2. Upload to S5, get CID
3. Calculate proofHash = keccak256(proofData)
4. Sign: signature = sign(keccak256(proofHash, hostAddress, tokensClaimed))  ← NEW
5. Submit: submitProofOfWork(sessionId, tokens, proofHash, signature, proofCID)
```

---

## 2. Implementation Guide

### Function Signature Change

```solidity
// OLD (4 parameters) - NO LONGER WORKS
function submitProofOfWork(
    uint256 jobId,
    uint256 tokensClaimed,
    bytes32 proofHash,
    string calldata proofCID
) external

// NEW (5 parameters) - REQUIRED
function submitProofOfWork(
    uint256 jobId,
    uint256 tokensClaimed,
    bytes32 proofHash,
    bytes calldata signature,  // NEW: 65 bytes ECDSA signature
    string calldata proofCID
) external
```

### Signature Generation

The signature must be generated by the **host wallet** (the wallet registered in NodeRegistry).

#### Step-by-Step Process

```
1. proofHash = keccak256(proofData)
2. dataHash = keccak256(abi.encodePacked(proofHash, hostAddress, tokensClaimed))
3. signature = wallet.signMessage(dataHash)  // EIP-191 personal sign
```

#### TypeScript/JavaScript Implementation

```typescript
import { ethers, keccak256, solidityPacked, getBytes, Wallet } from 'ethers';

interface ProofSubmissionData {
  sessionId: bigint;
  tokensClaimed: bigint;
  proofData: Uint8Array;  // Raw STARK proof bytes
  proofCID: string;       // S5 storage CID
}

class ProofSigner {
  private hostWallet: Wallet;
  private marketplace: ethers.Contract;

  constructor(hostPrivateKey: string, marketplaceAddress: string, provider: ethers.Provider) {
    this.hostWallet = new Wallet(hostPrivateKey, provider);
    this.marketplace = new ethers.Contract(
      marketplaceAddress,
      ['function submitProofOfWork(uint256,uint256,bytes32,bytes,string) external'],
      this.hostWallet
    );
  }

  /**
   * Generate signature for proof submission
   */
  signProof(proofHash: string, tokensClaimed: bigint): Promise<string> {
    // Create the data hash: keccak256(proofHash, hostAddress, tokensClaimed)
    const dataHash = keccak256(
      solidityPacked(
        ['bytes32', 'address', 'uint256'],
        [proofHash, this.hostWallet.address, tokensClaimed]
      )
    );

    // Sign using EIP-191 personal sign
    return this.hostWallet.signMessage(getBytes(dataHash));
  }

  /**
   * Submit proof with signature
   */
  async submitProof(data: ProofSubmissionData): Promise<ethers.TransactionReceipt> {
    const { sessionId, tokensClaimed, proofData, proofCID } = data;

    // Step 1: Hash the proof data
    const proofHash = keccak256(proofData);

    // Step 2: Sign the commitment
    const signature = await this.signProof(proofHash, tokensClaimed);

    // Step 3: Submit to contract
    const tx = await this.marketplace.submitProofOfWork(
      sessionId,
      tokensClaimed,
      proofHash,
      signature,
      proofCID
    );

    return tx.wait();
  }
}

// Usage
const signer = new ProofSigner(
  process.env.HOST_PRIVATE_KEY!,
  '0xeebEEbc9BCD35e81B06885b63f980FeC71d56e2D',
  provider
);

await signer.submitProof({
  sessionId: 42n,
  tokensClaimed: 1000n,
  proofData: starkProofBytes,
  proofCID: 'bafyreib...'
});
```

#### Python Implementation

```python
from eth_account import Account
from eth_account.messages import encode_defunct
from web3 import Web3

class ProofSigner:
    def __init__(self, host_private_key: str, marketplace_address: str, rpc_url: str):
        self.w3 = Web3(Web3.HTTPProvider(rpc_url))
        self.account = Account.from_key(host_private_key)
        self.marketplace = self.w3.eth.contract(
            address=marketplace_address,
            abi=MARKETPLACE_ABI
        )

    def sign_proof(self, proof_hash: bytes, tokens_claimed: int) -> bytes:
        """Generate signature for proof submission"""
        # Create data hash: keccak256(proofHash, hostAddress, tokensClaimed)
        data_hash = Web3.solidity_keccak(
            ['bytes32', 'address', 'uint256'],
            [proof_hash, self.account.address, tokens_claimed]
        )

        # Sign using EIP-191 personal sign
        message = encode_defunct(data_hash)
        signed = self.account.sign_message(message)

        # Return 65-byte signature (r + s + v)
        return signed.signature

    def submit_proof(
        self,
        session_id: int,
        tokens_claimed: int,
        proof_data: bytes,
        proof_cid: str
    ) -> str:
        """Submit proof with signature"""
        # Step 1: Hash the proof data
        proof_hash = Web3.keccak(proof_data)

        # Step 2: Sign the commitment
        signature = self.sign_proof(proof_hash, tokens_claimed)

        # Step 3: Submit to contract
        tx = self.marketplace.functions.submitProofOfWork(
            session_id,
            tokens_claimed,
            proof_hash,
            signature,
            proof_cid
        ).build_transaction({
            'from': self.account.address,
            'nonce': self.w3.eth.get_transaction_count(self.account.address),
            'gas': 200000,
        })

        signed_tx = self.account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)

        return self.w3.eth.wait_for_transaction_receipt(tx_hash)

# Usage
signer = ProofSigner(
    host_private_key=os.environ['HOST_PRIVATE_KEY'],
    marketplace_address='0xeebEEbc9BCD35e81B06885b63f980FeC71d56e2D',
    rpc_url='https://sepolia.base.org'
)

receipt = signer.submit_proof(
    session_id=42,
    tokens_claimed=1000,
    proof_data=stark_proof_bytes,
    proof_cid='bafyreib...'
)
```

#### Go Implementation

```go
package proofsubmit

import (
    "crypto/ecdsa"
    "math/big"

    "github.com/ethereum/go-ethereum/accounts/abi/bind"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/crypto"
)

type ProofSigner struct {
    privateKey  *ecdsa.PrivateKey
    hostAddress common.Address
    marketplace *JobMarketplace // Generated contract binding
}

func NewProofSigner(privateKeyHex string, marketplaceAddr string, client *ethclient.Client) (*ProofSigner, error) {
    privateKey, err := crypto.HexToECDSA(privateKeyHex)
    if err != nil {
        return nil, err
    }

    hostAddress := crypto.PubkeyToAddress(privateKey.PublicKey)
    marketplace, err := NewJobMarketplace(common.HexToAddress(marketplaceAddr), client)
    if err != nil {
        return nil, err
    }

    return &ProofSigner{
        privateKey:  privateKey,
        hostAddress: hostAddress,
        marketplace: marketplace,
    }, nil
}

func (s *ProofSigner) SignProof(proofHash [32]byte, tokensClaimed *big.Int) ([]byte, error) {
    // Create data hash: keccak256(proofHash, hostAddress, tokensClaimed)
    dataHash := crypto.Keccak256(
        proofHash[:],
        s.hostAddress.Bytes(),
        common.LeftPadBytes(tokensClaimed.Bytes(), 32),
    )

    // Create Ethereum signed message hash
    prefixedHash := crypto.Keccak256(
        []byte("\x19Ethereum Signed Message:\n32"),
        dataHash,
    )

    // Sign
    signature, err := crypto.Sign(prefixedHash, s.privateKey)
    if err != nil {
        return nil, err
    }

    // Adjust v value (Ethereum uses 27/28, crypto.Sign uses 0/1)
    if signature[64] < 27 {
        signature[64] += 27
    }

    return signature, nil
}

func (s *ProofSigner) SubmitProof(
    opts *bind.TransactOpts,
    sessionId *big.Int,
    tokensClaimed *big.Int,
    proofData []byte,
    proofCID string,
) (*types.Transaction, error) {
    // Step 1: Hash the proof data
    proofHash := crypto.Keccak256Hash(proofData)

    // Step 2: Sign the commitment
    signature, err := s.SignProof(proofHash, tokensClaimed)
    if err != nil {
        return nil, err
    }

    // Step 3: Submit to contract
    return s.marketplace.SubmitProofOfWork(
        opts,
        sessionId,
        tokensClaimed,
        proofHash,
        signature,
        proofCID,
    )
}
```

#### Rust Implementation

```rust
use ethers::{
    prelude::*,
    utils::keccak256,
};

pub struct ProofSigner {
    wallet: LocalWallet,
    marketplace: JobMarketplace<SignerMiddleware<Provider<Http>, LocalWallet>>,
}

impl ProofSigner {
    pub async fn new(
        private_key: &str,
        marketplace_address: &str,
        rpc_url: &str,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let provider = Provider::<Http>::try_from(rpc_url)?;
        let wallet: LocalWallet = private_key.parse()?;
        let wallet = wallet.with_chain_id(84532u64); // Base Sepolia

        let client = SignerMiddleware::new(provider, wallet.clone());
        let marketplace = JobMarketplace::new(
            marketplace_address.parse()?,
            Arc::new(client),
        );

        Ok(Self { wallet, marketplace })
    }

    pub async fn sign_proof(
        &self,
        proof_hash: [u8; 32],
        tokens_claimed: U256,
    ) -> Result<Bytes, Box<dyn std::error::Error>> {
        // Create data hash: keccak256(proofHash, hostAddress, tokensClaimed)
        let mut data = Vec::new();
        data.extend_from_slice(&proof_hash);
        data.extend_from_slice(self.wallet.address().as_bytes());
        data.extend_from_slice(&tokens_claimed.to_be_bytes::<32>());

        let data_hash = keccak256(&data);

        // Sign using EIP-191
        let signature = self.wallet.sign_message(&data_hash).await?;

        Ok(signature.to_vec().into())
    }

    pub async fn submit_proof(
        &self,
        session_id: U256,
        tokens_claimed: U256,
        proof_data: &[u8],
        proof_cid: String,
    ) -> Result<TransactionReceipt, Box<dyn std::error::Error>> {
        // Step 1: Hash the proof data
        let proof_hash = keccak256(proof_data);

        // Step 2: Sign the commitment
        let signature = self.sign_proof(proof_hash, tokens_claimed).await?;

        // Step 3: Submit to contract
        let tx = self.marketplace
            .submit_proof_of_work(
                session_id,
                tokens_claimed,
                proof_hash,
                signature,
                proof_cid,
            )
            .send()
            .await?
            .await?;

        Ok(tx.unwrap())
    }
}
```

---

## 3. Error Handling

### New Error Messages

| Error | Cause | Fix |
|-------|-------|-----|
| `"Invalid signature length"` | Signature not exactly 65 bytes | Check signing library output format |
| `"Invalid proof signature"` | Wrong signer | Ensure host wallet matches session.host |
| `"Invalid proof signature"` | Malformed signature | Check r, s, v values are correct |
| `"Invalid proof signature"` | Replay attack | Each proofHash can only be used once |

### Debugging Signature Issues

```typescript
// Verify signature before submitting (for debugging)
function verifySignatureLocally(
  proofHash: string,
  hostAddress: string,
  tokensClaimed: bigint,
  signature: string
): boolean {
  const dataHash = keccak256(
    solidityPacked(
      ['bytes32', 'address', 'uint256'],
      [proofHash, hostAddress, tokensClaimed]
    )
  );

  const recoveredAddress = ethers.verifyMessage(getBytes(dataHash), signature);
  return recoveredAddress.toLowerCase() === hostAddress.toLowerCase();
}
```

---

## 4. Critical Requirements

### Wallet Identity

The signing wallet **MUST** be:
1. The same wallet registered in NodeRegistry
2. The same wallet that is `session.host` for this session

If you use a different wallet, the signature will be rejected.

### Replay Protection

Each `proofHash` can only be used **once across all sessions**. After a successful submission:
- The proofHash is marked as "verified" in ProofSystem
- Any subsequent submission with the same proofHash will fail

This means:
- Every proof submission must have unique proof data
- You cannot resubmit the same proof even for different sessions

### Signature Format

The signature must be exactly **65 bytes** in r, s, v format:
- `r`: 32 bytes
- `s`: 32 bytes
- `v`: 1 byte (27 or 28)

Some signing libraries return v as 0 or 1. Adjust to 27/28 if needed:
```javascript
if (signature[64] < 27) {
  signature[64] += 27;
}
```

---

## 5. Integration with Existing Node Flow

### Before (Old Flow)

```
┌─────────────────────────────────────────────────────────────┐
│                     Host Node Software                       │
├─────────────────────────────────────────────────────────────┤
│  1. Receive inference request                                │
│  2. Generate tokens (run LLM)                                │
│  3. Track token count                                        │
│  4. At checkpoint interval:                                  │
│     a. Generate STARK proof                                  │
│     b. Upload proof to S5 → get CID                          │
│     c. proofHash = keccak256(proof)                          │
│     d. Submit: submitProofOfWork(session, tokens, hash, cid) │
│  5. Continue generating tokens                               │
└─────────────────────────────────────────────────────────────┘
```

### After (New Flow)

```
┌─────────────────────────────────────────────────────────────┐
│                     Host Node Software                       │
├─────────────────────────────────────────────────────────────┤
│  1. Receive inference request                                │
│  2. Generate tokens (run LLM)                                │
│  3. Track token count                                        │
│  4. At checkpoint interval:                                  │
│     a. Generate STARK proof                                  │
│     b. Upload proof to S5 → get CID                          │
│     c. proofHash = keccak256(proof)                          │
│     d. dataHash = keccak256(proofHash, hostAddr, tokens) ← NEW│
│     e. signature = wallet.signMessage(dataHash)          ← NEW│
│     f. Submit: submitProofOfWork(session, tokens, hash,      │
│                                  signature, cid)         ← NEW│
│  5. Continue generating tokens                               │
└─────────────────────────────────────────────────────────────┘
```

### Code Diff

```diff
  async function submitCheckpoint(
    sessionId: bigint,
    tokensClaimed: bigint,
    proofData: Uint8Array,
    proofCID: string
  ) {
    const proofHash = keccak256(proofData);

+   // NEW: Generate signature
+   const dataHash = keccak256(
+     solidityPacked(
+       ['bytes32', 'address', 'uint256'],
+       [proofHash, hostWallet.address, tokensClaimed]
+     )
+   );
+   const signature = await hostWallet.signMessage(getBytes(dataHash));

    await marketplace.submitProofOfWork(
      sessionId,
      tokensClaimed,
      proofHash,
+     signature,  // NEW parameter
      proofCID
    );
  }
```

---

## 6. Contract Addresses

### Proxy Addresses (Use These)

```
JobMarketplace: 0xeebEEbc9BCD35e81B06885b63f980FeC71d56e2D
ProofSystem:    0x5afB91977e69Cc5003288849059bc62d47E7deeb
NodeRegistry:   0x8BC0Af4aAa2dfb99699B1A24bA85E507de10Fd22
HostEarnings:   0xE4F33e9e132E60fc3477509f99b9E1340b91Aee0
```

### ABI Update

Get the latest ABI from `client-abis/JobMarketplaceWithModelsUpgradeable-CLIENT-ABI.json`

The key change in the ABI:
```json
{
  "name": "submitProofOfWork",
  "inputs": [
    { "name": "jobId", "type": "uint256" },
    { "name": "tokensClaimed", "type": "uint256" },
    { "name": "proofHash", "type": "bytes32" },
    { "name": "signature", "type": "bytes" },
    { "name": "proofCID", "type": "string" }
  ]
}
```

---

## 7. Migration Checklist

### Required Changes

- [ ] Update ABI for JobMarketplace (new 5-param submitProofOfWork)
- [ ] Implement signature generation function
- [ ] Update proof submission to include signature as 4th parameter
- [ ] Ensure host wallet private key is available for signing
- [ ] Add error handling for new signature errors

### Testing Checklist

- [ ] Generate signature and verify locally before submitting
- [ ] Test successful proof submission with valid signature
- [ ] Test that wrong wallet signature is rejected
- [ ] Test that replay (same proofHash twice) is rejected
- [ ] Verify proofHash uniqueness in production

### Security Considerations

- [ ] Host private key must be securely stored
- [ ] Never log or expose signatures
- [ ] Implement retry logic for transient failures (not signature failures)

---

## 8. Quick Reference

### Signature Generation Formula

```
dataHash = keccak256(abi.encodePacked(proofHash, hostAddress, tokensClaimed))
signature = wallet.signMessage(dataHash)  // EIP-191 personal_sign
```

### Contract Verification (On-Chain)

```solidity
bytes32 ethSignedMessageHash = keccak256(abi.encodePacked(
    "\x19Ethereum Signed Message:\n32",
    keccak256(abi.encodePacked(proofHash, prover, claimedTokens))
));
address recoveredSigner = ecrecover(ethSignedMessageHash, v, r, s);
require(recoveredSigner == session.host, "Invalid proof signature");
```

### Parameter Order

```
submitProofOfWork(
  jobId,          // uint256 - Session ID
  tokensClaimed,  // uint256 - Token count
  proofHash,      // bytes32 - keccak256(proofData)
  signature,      // bytes   - 65-byte ECDSA signature ← NEW
  proofCID        // string  - S5 storage CID
)
```

---

## 9. Support

For questions about this migration:
- Review `docs/API_REFERENCE.md` for full API documentation
- See `client-abis/CHANGELOG.md` for detailed change history
- Check `test/SecurityFixes/JobMarketplace/test_proofsystem_integration.t.sol` for test examples

---

**Document Version:** 1.0
**Last Updated:** January 6, 2026
